# 1. Overview and Installation

RSARTE implements the real-time subset of the Unified Modeling Language (UML) together with C/C++ code generation to support designing and developing real-time applications that are characterized by:
- multithreaded execution of components that communicate via messaging
- implement state-machine based logic.

C++ code generated by RSARTE uses a run-time library called the RT Services Library. 
- This provides run-time implementations of UML real-time model constructs 
- Some library services are automatically used by generated C++ code
- Other services are used by provided application code.

---

## Timeline of IBM/HCL DevOps Model RealTime

### Rational Rose RealTime (Predecessor)

Era: 1990s–2000s

- IBM's Rational Rose RealTime (RoseRT) was a early tool for model-driven development of real-time systems, based on UML 1.x with custom real-time extensions.
- It was part of an attempt to produce an end-to-end (e2e) toolchain for engineering software systems.
- Extension of early work in "model-to-code" systems to generate COBOL and ALGOL code from models, usually flow charts and data flow diagrams
- Built as a Windows MFC application, it supported limited cross-platform capabilities.

### IBM Rational Software Architect RealTime Edition (RSARTE)

Era: Early 2010s

- RSARTE was a major platform revision marked by the milestones of adopting the Eclipse IDE and the UML 2.x standard.
- Utilized the Eclipse Modeling Framework (EMF).
- Supported UML-RT for real-time system modeling.
- Enhanced team collaboration through better version control integration.

### IBM DevOps Model RealTime

Era: Mid-2010s

- Rebranded from RSARTE, this version emphasized DevOps integration, aligning modeling tools with continuous integration and delivery (CICD) practices.
- Improved support for DevOps workflows.
- Enhanced code generation and synchronization capabilities.
- Better integration with modern version control systems like Git.

### HCL DevOps Model RealTime

Era: 2020–Present

- HCL acquired certain IBM software products including DevOps Realtime
- DevOps Model RealTime continued under HCL's stewardship, 
- Provided regular updates, with new production versions released approximately every six weeks.
- Introduction of DevOps Code RealTime, a complementary tool for text-centric development in Visual Studio Code and Eclipse Theia (not covered in this course)

---

## Installation

- The product is distributed as a set of plugins and features for Eclipse.
- There are a number of different ways to install the product. 
  - An interactively performed local installation
  - A command-line based installation suitable for scripting
  - An installation based on the Eclipse Installer
- These three methods are covered in the resource `ModelRealTime InstallFromUpdateSite_12_1.pdf` in the resources directory `Installation And Setup` 
- We do not have time to cover these in class.


#### Installation Script

- IBM provides an installation script which installs the product and all its dependencies from scratch, including eclipse and the necessary jre.
- The script was used to install the product in your VM.
- The script can be found in the resources directory in this module along with the notes for customization

The installation script relies on a number of environment variables that can be configured
- RT_DOWNLOADS -- full path to folder with downloads. The script will search for eclipse installation files in that folder, or download from eclipse.org to that location. By default, $HOME/Downloads is used.
- RT_INSTALL_BASE -- full path to top folder with all installations, default value is $HOME/Install
- RT_INSTALL -- full path to the installation location. The path can be a pattern containing special @identifiers@ that will be replaced by actual values by the install script:
  - @PRODUCT@ -- the name of product in upper case, for example, Model RealTime
  - @product@ -- the name of the product in lower case
  - @VERSION@ -- version number, for example, 12.1
  - @RELEASE@ -- identifier of the release, for example, 2023.04
  - @BUILD@ -- build number
  - Default value is $RT_INSTALL_BASE/@PRODUCT@_@VERSION@_@RELEASE@
  - For example, by default, the tool will be installed into $RT_INSTALL_MODELRT12.10
- RT_INSTALL_COMPONENTS -- comma separated list of components to be installed. By default, core,extra,integrations components are installed.
- RT_INSTALL_FORCE_OVERWRITE -- do not ask before overwriting installation folder if it already exists
- RT_JAVA17_BIN -- full path to Java 17 binary, if not specified and JAVA 17 is not found under $RT_INSTALL_BASE, it will be downloaded and installed automatically
- RT_JAVA21_BIN -- full path to Java 21 binary, if not specified and JAVA 21 is not found under $RT_INSTALL_BASE, it will be downloaded and installed automatically
- RT_START_AFTER_INSTALL -- set to some value if the product should be started immediately after installation
- RT_TEST -- full path to the folder where the workspace for running the tool after installation will be created. If START_AFTER_INSTALL is not set, RT_TEST can be omitted.

These can be set at the top of the script file.

```bash
# Full path to folder with downloads for eclipse and product zips
DOWNLOADS=$RT_DOWNLOADS

# Full path to top folder with installation
INSTALL_BASE=$RT_INSTALL_BASE

# Full path pattern to installation location
INSTALL=$RT_INSTALL

# Set the JAVA17_BIN variable to the path of the Java 17 binary from the RT_JAVA17_BIN environment variable
JAVA17_BIN=$RT_JAVA17_BIN

# Set the JAVA21_BIN variable to the path of the Java 21 binary from the RT_JAVA21_BIN environment variable
JAVA21_BIN=$RT_JAVA21_BIN

# Set START_AFTER_INSTALL to some value if the product should be started immediately after installation
START_AFTER_INSTALL=$RT_START_AFTER_INSTALL

# Full path to the folder where workspace for running the tool after installation will be created
# If START_AFTER_INSTALL is not set, RT_TEST is not used and can be ignored
TESTS=$RT_TEST
```

---

## Key Use Cases of DevOps Model RealTime

Embedded Systems Development
- Real-time control systems for automotive ECUs, avionics, defense systems, and industrial automation.
- Modeling complex software behavior for deterministic, time-critical applications.
- Example: Cruise control logic in cars, radar subsystems, or factory control loops.
- Case Study: Accelerating Innovation in Embedded Systems by Adopting DevOps

Telecommunications Systems
- Protocol stacks, call routing, and network resource management.
- UML-RT’s capsule model suits asynchronous, event-driven telecom systems.
- Example: GSM/5G base station software or telecom switching applications.

Robotics and IoT
- Behavior modeling for distributed sensor/actuator control logic.
- Supports code generation for embedded targets (e.g., ARM).
- Example: Warehouse robotics systems, smart grid controllers. 

Safety-Critical and Regulated Systems
- Support for modeling traceability and code generation aligned with standards (e.g., DO-178C, ISO 26262).
- Helps in certifiable design through well-structured model artifacts.

Legacy Migration and Modernization
- A migration path from older modeling tools like Rational Rose RealTime.
- Enables reuse of design assets in modern Eclipse-based tooling with DevOps integration.

Model-Driven DevOps Integration
- Supports CI/CD workflows for model-based development.
- Generates testable C++ code automatically from UML-RT diagrams.
- Example: Integration with Jenkins, Git, and artifact repositories in safety-critical environments.

---

## Key Differences Between RSARTE Version 11 and Version 12

These are described in more detail in the document in the Installation and Setup resouces directory titled `WhatsNew_Model_RealTime_12_1_2.pdf`

#### Eclipse Platform Upgrade
- Version 12 is built on Eclipse 4.32 (2024.06), offering enhanced support for multi-monitor setups and improved UI performance.
- Version 11 relied on an earlier Eclipse version, which may lack these enhancements. 

#### Performance Enhancements
- Version 12 introduces a preference to limit the number of items shown in views like Problems and Project Explorer, improving UI responsiveness.
- This feature is controlled by a new preference: General → Initial maximum number of elements shown in views (default is 1000).

#### Improved Workspace Handling

- The launch dialog in Version 12 now displays the resolved path of the workspace, aiding in clarity when using relative paths or special characters.

#### Enhanced Compare/Merge Editor
- The text file Compare/Merge editor now shows the total number of differences, aligning with the model Compare/Merge editor's functionality.
  
---

## Potential Issues During Migration

#### Model Fragmentation and Controlled Units

- RSARTE can use "fragments" to manage model components. 
- When migrating, it's crucial to decide how controlled units from Version 11 will map to fragments in Version 12.
- Improper mapping can lead to issues in model organization and version control.

#### Incremental Migration Challenges

- Migrating large models incrementally requires careful planning. 
- RSARTE provides mechanisms like "shadow packages" to facilitate this, but misconfiguration can cause synchronization issues.
   
#### Tooling and Plugin Compatibility

- Custom plugins or extensions developed for Version 11 may not be compatible with Version 12 due to changes in the underlying Eclipse platform.

- Testing and possibly updating these tools are necessary to maintain functionality.

#### Build and Code Generation Differences

- Updates in code generation templates or build processes between versions may affect the output.
- Reviewing and adjusting build configurations is essential to ensure consistency.
  
---

## Migration Best Practices

#### Backup Models
- Always create backups of the models before initiating the migration process.

#### Plan Fragmentation Strategy
- Decide on how to structure the model fragments to align with team workflows and version control practices.

#### Test Incrementally
- If possible, migrate and test components incrementally to identify and address issues early.

#### Update Custom Tools
- Review and update any custom plugins or scripts to ensure compatibility with the new version.

#### Review Build Configurations 
- Ensure that build scripts and code generation settings are updated to reflect any changes in Version 12.

---

## Migration Considerations (from v11 to v12)

#### Mapping controlled units to new fragment files
- In v12, RSARTE uses .efx for modularization. 
- During migration, the tool must correctly re-link the old units to new .efx fragments.

#### Structure mismatch: 
- Improper migration may result in model elements not loading or being duplicated in the workspace.

#### Shadow Packages
- A shadow package is a placeholder or reference in the model that points to an external package, typically stored in a separate file (e.g., .efx fragment). 
- It allows the main model (.emx) to reference content that resides in another model file without duplicating it.
- Appears in the model explorer as a dimmed or ghosted package icon
- Contains no editable elements directly, but acts as a pointer
- When the referenced model is loaded, the full contents are resolved into view
- Often used for reused libraries or shared components

Use Cases
- Modular development across multiple teams
- Reference to a common protocol library or type system
- Incremental model loading to improve performance

Issues During Migration:
- If the referenced fragment isn’t available or correctly linked, the shadow package may remain unresolved, causing issues in code generation or simulation.

#### Ghost Elements
- Ghost elements are unresolved references to model elements that used to exist or are expected to be found in an external file, but RSARTE cannot locate or resolve them in the current workspace.

Common Symptoms:
- Appear with a greyed-out icon or placeholder label
- Can show up in diagrams, state machines, or capsule structures
- Typically result from:
  - Incomplete model import
  - Missing .efx fragments
  - Incorrect workspace setup or file path
- Ghost elements break model integrity and may prevent builds or simulations
  - RSARTE cannot generate code from ghost elements 
  - Diagrams may display them incorrectly or not at all

#### Resolutions 

For Shadow Packages:
- Ensure the external fragment is:
  - Present in the workspace 
  - Properly referenced in the .emx model or .etx transform config

For Ghost Elements:

- Use `Model Problems View` to identify the missing references
- Import or re-link the required fragments
- Check your workspace settings and classpath
- Validate that controlled units are checked into version control and correctly mapped